<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Group Video Call (Scaledrone)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; background: #f0f2f4; margin: 0; padding: 20px; }
    .container { max-width: 900px; margin: 0 auto; background: #fff; border-radius: 8px; box-shadow: 0 2px 8px #ccc; padding: 20px; }
    h2 { margin-top: 0; text-align: center; }
    #buttons { text-align: center; margin-bottom: 10px; }
    button { margin: 6px 12px; padding: 10px 20px; font-size: 1rem; }
    #status { text-align: center; margin: 10px 0; font-weight: 600; color: #333; }
    #members { margin: 10px 0; }
    #videos {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
    }
    video {
      border-radius: 8px;
      background: #000;
      max-width: 280px;
      width: 100%;
      height: auto;
      box-shadow: 0 0 6px rgba(0,0,0,0.15);
    }
    .video-block {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .video-label {
      margin-top: 6px;
      font-size: 0.9rem;
      color: #333;
      text-align: center;
      max-width: 280px;
      word-break: break-word;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>WebRTC Group Video Call (Scaledrone)</h2>
    <div id="buttons">
      <button id="startCallBtn">Start Call</button>
      <button id="joinCallBtn">Join Call</button>
    </div>
    <div id="status"></div>
    <div id="members"></div>
    <div id="videos">
      <div class="video-block">
        <video id="localVideo" autoplay muted playsinline></video>
        <div class="video-label">You (Muted locally)</div>
      </div>
      <!-- Remote videos appended here -->
    </div>
  </div>

  <script src="https://cdn.scaledrone.com/scaledrone.min.js"></script>
  <script>
    const CHANNEL_ID = 'EoIG3R1I4JdyS4L1'; // Replace with your Scaledrone channel ID
    const ROOM_NAME = 'observable-voip-group-room';

    let drone = null, room = null, localStream = null;
    let members = [];
    const peerConnections = {};
    const videoElements = {};
    const iceCandidateQueues = {};

    const startCallBtn = document.getElementById('startCallBtn');
    const joinCallBtn = document.getElementById('joinCallBtn');
    const statusEl = document.getElementById('status');
    const membersEl = document.getElementById('members');
    const videosEl = document.getElementById('videos');
    const localVideo = document.getElementById('localVideo');

    function logStatus(msg) { statusEl.textContent = msg; }

    function showMembersWithStatus() {
      membersEl.innerHTML = "<strong>Room members:</strong><br>";
      members.forEach(m => {
        const div = document.createElement('div');
        div.textContent = m.id + (m.id === drone.clientId ? " (You)" : "");
        if (m.id === drone.clientId) div.style.fontWeight = "bold";
        if (peerConnections[m.id]) {
          div.style.color = 'green';
          div.textContent += " ðŸŒ Connected";
        }
        membersEl.appendChild(div);
      });
    }

    drone = new ScaleDrone(CHANNEL_ID);
    drone.on('open', error => {
      if (error) { logStatus("Scaledrone connection failed."); return; }
      logStatus("Connected to Scaledrone.");
      room = drone.subscribe(ROOM_NAME);

      room.on('open', err => {
        if (err) { logStatus("Room join error."); }
      });

      room.on('members', ms => {
        members = ms;
        showMembersWithStatus();
      });

      room.on('member_join', member => {
        members.push(member);
        showMembersWithStatus();
      });

      room.on('member_leave', member => {
        members = members.filter(m => m.id !== member.id);
        if (peerConnections[member.id]) {
          peerConnections[member.id].close();
          delete peerConnections[member.id];
        }
        if (videoElements[member.id]) {
          videoElements[member.id].remove();
          delete videoElements[member.id];
        }
        showMembersWithStatus();
      });

      room.on('data', (data, client) => {
        if (!client || client.id === drone.clientId) return;
        handleSignalingData(data, client.id);
      });
    });

    function sendSignal(targetId, body) {
      drone.publish({
        room: ROOM_NAME,
        message: {
          to: targetId,
          from: drone.clientId,
          data: body
        }
      });
    }

    startCallBtn.onclick = async function () {
      if (!localStream) {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
          localVideo.srcObject = localStream;
          members.forEach(m => {
            if (m.id !== drone.clientId) createPeerConnection(m.id, true);
          });
          showMembersWithStatus();
          logStatus("Start Call: local media acquired and connections initiated.");
        } catch(e) {
          logStatus("Could not access camera/microphone.");
          return;
        }
      }
      members.forEach(m => {
        if (m.id !== drone.clientId) sendSignal(m.id, { type: 'JOIN_CALL' });
      });
      logStatus("Start Call: invited others to join.");
    };

    joinCallBtn.onclick = async function () {
      if (localStream) return;
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
        localVideo.srcObject = localStream;
        members.forEach(m => {
          if (m.id !== drone.clientId) createPeerConnection(m.id, true);
        });
        showMembersWithStatus();
        logStatus("Joined call. Connecting...");
      } catch (e) {
        logStatus("Could not access camera/microphone.");
      }
    };

    function createPeerConnection(peerId, isInitiator) {
      if (peerConnections[peerId]) return peerConnections[peerId];

      const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
      peerConnections[peerId] = pc;
      iceCandidateQueues[peerId] = [];
      showMembersWithStatus();

      if (localStream) {
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      }

      pc.onicecandidate = event => {
        if (event.candidate) sendSignal(peerId, { type: 'ICE', candidate: event.candidate });
      };

      pc.ontrack = event => {
        if (!videoElements[peerId]) {
          const video = document.createElement('video');
          video.id = 'remote-video-' + peerId;
          video.autoplay = true;
          video.playsInline = true;
          video.controls = true;
          video.style.maxWidth = "280px";
          video.style.borderRadius = "8px";
          const block = document.createElement('div');
          block.className = 'video-block';
          const label = document.createElement('div');
          label.className = 'video-label';
          label.textContent = 'Remote: ' + peerId;
          block.appendChild(video);
          block.appendChild(label);
          videosEl.appendChild(block);
          videoElements[peerId] = block;
        }
        videoElements[peerId].querySelector('video').srcObject = event.streams[0];
      };

      if (isInitiator) {
        pc.createOffer()
          .then(offer => pc.setLocalDescription(offer))
          .then(() => sendSignal(peerId, { type: 'OFFER', sdp: pc.localDescription }));
      }

      return pc;
    }

    async function handleSignalingData(message, fromId) {
      const { type, sdp, candidate } = message.data || message;
      if (message.to && message.to !== drone.clientId) return;

      switch (type) {
        case 'JOIN_CALL':
          if (localStream) createPeerConnection(fromId, false);
          break;
        case 'OFFER': {
          const pc = peerConnections[fromId] || createPeerConnection(fromId, false);
          await pc.setRemoteDescription(new RTCSessionDescription(sdp));
          for (let c of iceCandidateQueues[fromId]) {
            await pc.addIceCandidate(c);
          }
          iceCandidateQueues[fromId] = [];
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          sendSignal(fromId, { type: 'ANSWER', sdp: pc.localDescription });
          break;
        }
        case 'ANSWER': {
          const pc = peerConnections[fromId];
          if (!pc) return;
          await pc.setRemoteDescription(new RTCSessionDescription(sdp));
          for (let c of iceCandidateQueues[fromId]) {
            await pc.addIceCandidate(c);
          }
          iceCandidateQueues[fromId] = [];
          break;
        }
        case 'ICE': {
          const pc = peerConnections[fromId];
          if (!pc) return;
          const iceCandidate = new RTCIceCandidate(candidate);
          if (pc.remoteDescription && pc.remoteDescription.type) {
            await pc.addIceCandidate(iceCandidate);
          } else {
            iceCandidateQueues[fromId].push(iceCandidate);
          }
          break;
        }
      }
      showMembersWithStatus();
    }
  </script>
</body>
</html>
