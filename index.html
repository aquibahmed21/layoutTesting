<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Group VOIP Call (Scaledrone)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; background: #f0f2f4; }
    .container { max-width: 640px; margin: 48px auto; background: #fff; border-radius: 8px; box-shadow: 0 2px 8px #ccc; padding: 28px;}
    h2 { margin-top: 0; }
    #status { display: block; margin: 10px 0 20px 0; font-size: 1em; }
    button { margin: 7px 12px 7px 0; padding: 10px 18px; font-size: 1em;}
    #members, .audio-list { margin-top: 20px; }
    .audio-block { margin-bottom: 16px; }
    .audio-label { font-size: .92em; color: #444; margin-bottom: 3px; display: block; }
    .connected { color: #0a0; font-weight: 600; }
  </style>
</head>
<body>
  <div class="container">
    <h2>WebRTC Group VoIP Call (Scaledrone)</h2>
    <button id="startCallBtn">Start Call</button>
    <button id="joinCallBtn">Join Call</button>
    <span id="status"></span>
    <div id="members"></div>
    <div class="audio-list" id="audioList">
      <div class="audio-block">
        <span class="audio-label">Your audio (muted locally)</span>
        <audio id="localAudio" autoplay muted></audio>
      </div>
      <!-- Remote audios appended dynamically -->
    </div>
  </div>
  <script src="https://cdn.scaledrone.com/scaledrone.min.js"></script>
  <script>
    const CHANNEL_ID = 'EoIG3R1I4JdyS4L1'; // Replace this!
    const ROOM_NAME = 'observable-voip-group-room';

    let drone = null, room = null, localStream = null;
    let members = [];
    const peerConnections = {};
    const audioElements = {};
    const iceCandidateQueues = {}; // New: queues per peer for ICE candidates received early

    const startCallBtn = document.getElementById('startCallBtn');
    const joinCallBtn = document.getElementById('joinCallBtn');
    const statusEl = document.getElementById('status');
    const audioList = document.getElementById('audioList');
    const membersEl = document.getElementById('members');
    const localAudio = document.getElementById('localAudio');

    function logStatus(msg) { statusEl.textContent = msg; }

    function showMembersWithStatus() {
      membersEl.innerHTML = "<strong>Room members:</strong><br>";
      members.forEach(m => {
        const div = document.createElement('div');
        div.textContent = m.id + (m.id === drone.clientId ? " (You)" : "");
        if (m.id === drone.clientId) div.style.fontWeight = "bold";
        if (peerConnections[m.id]) {
          div.className = "connected";
          div.textContent += " ðŸŒ Connected";
        }
        membersEl.appendChild(div);
      });
    }

    drone = new ScaleDrone(CHANNEL_ID);
    drone.on('open', error => {
      if (error) { logStatus("Scaledrone connection failed."); return; }
      logStatus("Connected to Scaledrone.");
      room = drone.subscribe(ROOM_NAME);

      room.on('open', err => {
        if (err) { logStatus("Room join error."); }
      });

      room.on('members', ms => {
        members = ms;
        showMembersWithStatus();
      });

      room.on('member_join', member => {
        members.push(member);
        showMembersWithStatus();
      });

      room.on('member_leave', member => {
        members = members.filter(m => m.id !== member.id);
        if (peerConnections[member.id]) {
          peerConnections[member.id].close();
          delete peerConnections[member.id];
        }
        if (audioElements[member.id]) {
          audioElements[member.id].remove();
          delete audioElements[member.id];
        }
        showMembersWithStatus();
      });

      room.on('data', (data, client) => {
        if (!client || client.id === drone.clientId) return;
        handleSignalingData(data, client.id);
      });
    });

    function sendSignal(targetId, body) {
      drone.publish({
        room: ROOM_NAME,
        message: {
          to: targetId,
          from: drone.clientId,
          data: body
        }
      });
    }

    startCallBtn.onclick = function () {
      members.forEach(m => {
        if (m.id !== drone.clientId) sendSignal(m.id, { type: 'JOIN_CALL' });
      });
      logStatus("Start Call: invited others to join.");
    };

    joinCallBtn.onclick = async function() {
      if (localStream) return;
      try {
        localStream = await navigator.mediaDevices.getUserMedia({audio: true, video: false});
        localAudio.srcObject = localStream;
        members.forEach(m => {
          if (m.id !== drone.clientId) createPeerConnection(m.id, true);
        });
        showMembersWithStatus();
        logStatus("Joined call. Connecting...");
      } catch (e) {
        logStatus("Could not access microphone.");
      }
    };

    function createPeerConnection(peerId, isInitiator) {
      if (peerConnections[peerId]) return peerConnections[peerId];

      const pc = new RTCPeerConnection({iceServers: [{urls: 'stun:stun.l.google.com:19302'}]});
      peerConnections[peerId] = pc;
      iceCandidateQueues[peerId] = [];

      if (localStream) {
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      }

      pc.onicecandidate = event => {
        if (event.candidate) sendSignal(peerId, { type: 'ICE', candidate: event.candidate });
      };

      pc.ontrack = event => {
        let el = audioElements[peerId];
        if (!el) {
          el = document.createElement('audio');
          el.id = 'remote-audio-' + peerId;
          el.autoplay = true;
          el.controls = true;
          el.muted = false;
          let label = document.createElement('span');
          label.className = "audio-label";
          label.textContent = "Remote audio: " + peerId;
          let block = document.createElement('div');
          block.className = "audio-block";
          block.appendChild(label);
          block.appendChild(el);
          audioList.appendChild(block);
          audioElements[peerId] = el;
        }
        el.srcObject = event.streams[0];
      };

      if (isInitiator) {
        pc.createOffer()
          .then(offer => pc.setLocalDescription(offer))
          .then(() => sendSignal(peerId, { type: 'OFFER', sdp: pc.localDescription }));
      }
      return pc;
    }

    async function handleSignalingData(message, fromId) {
      const { type, sdp, candidate } = message.data || message;
      if (message.to && message.to !== drone.clientId) return;

      switch (type) {
        case 'JOIN_CALL':
          if (localStream) createPeerConnection(fromId, false);
          break;
        case 'OFFER': {
          const pc = peerConnections[fromId] || createPeerConnection(fromId, false);
          await pc.setRemoteDescription(new RTCSessionDescription(sdp));
          // Add any queued ICE candidates now
          for (let c of iceCandidateQueues[fromId]) {
            await pc.addIceCandidate(c);
          }
          iceCandidateQueues[fromId] = [];
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          sendSignal(fromId, { type: 'ANSWER', sdp: pc.localDescription });
          break;
        }
        case 'ANSWER': {
          const pc = peerConnections[fromId];
          if (!pc) return;
          await pc.setRemoteDescription(new RTCSessionDescription(sdp));
          // Add any queued ICE candidates now
          for (let c of iceCandidateQueues[fromId]) {
            await pc.addIceCandidate(c);
          }
          iceCandidateQueues[fromId] = [];
          break;
        }
        case 'ICE': {
          const pc = peerConnections[fromId];
          if (!pc) return;
          const iceCandidate = new RTCIceCandidate(candidate);
          if (pc.remoteDescription && pc.remoteDescription.type) {
            await pc.addIceCandidate(iceCandidate);
          } else {
            // Queue candidate if remoteDescription not set
            iceCandidateQueues[fromId].push(iceCandidate);
          }
          break;
        }
      }
      showMembersWithStatus();
    }
  </script>
</body>
</html>
