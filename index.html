<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Professional WebRTC Group Video Call</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');

    body {
      font-family: 'Inter', sans-serif;
      background: #121212;
      margin: 0;
      padding: 20px;
      color: #f0f0f0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      box-sizing: border-box;
    }

    .container {
      max-width: 1080px;
      margin: 0 auto;
      background: #1e1e1e;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.7);
      padding: 24px 32px;
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    h1 {
      text-align: center;
      font-weight: 600;
      color: #fff;
      margin-bottom: 12px;
      letter-spacing: 1px;
    }

    #buttons {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-bottom: 20px;
    }

    button {
      background-color: #3f51b5;
      border: none;
      padding: 12px 28px;
      color: white;
      font-weight: 600;
      font-size: 1rem;
      border-radius: 9999px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(63,81,181,0.5);
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
    }

    button:hover:not(:disabled) {
      background-color: #303f9f;
      box-shadow: 0 6px 16px rgba(48,63,159,0.7);
    }

    button:disabled {
      background-color: #555;
      cursor: not-allowed;
      box-shadow: none;
    }

    #status {
      text-align: center;
      font-weight: 600;
      color: #81d4fa;
      min-height: 24px;
      margin-bottom: 12px;
      font-size: 1.1rem;
      letter-spacing: 0.03em;
    }

    #members {
      text-align: center;
      margin-bottom: 24px;
      font-size: 0.9rem;
      color: #bbb;
      user-select: none;
      min-height: 20px;
      word-break: break-word;
    }

    #videos {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      justify-items: center;
      overflow-y: auto;
    }

    .video-block {
      position: relative;
      width: 100%;
      max-width: 280px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.7);
      background: #000;
      overflow: hidden;
    }

    video {
      width: 100%;
      height: auto;
      background: black;
      object-fit: cover;
      border-radius: 12px;
      display: block;
    }

    .video-label {
      position: absolute;
      bottom: 8px;
      left: 8px;
      right: 8px;
      background-color: rgba(0,0,0,0.6);
      color: #81d4fa;
      font-weight: 600;
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 0.9rem;
      text-align: center;
      user-select: text;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Professional WebRTC Group Video Call</h1>
    <div id="buttons">
      <button id="startCallBtn">Start Call</button>
      <button id="joinCallBtn">Join Call</button>
    </div>
    <div id="status"></div>
    <div id="members"></div>
    <div id="videos">
      <div class="video-block">
        <video id="localVideo" autoplay muted playsinline></video>
        <div class="video-label" title="You">You (Muted locally)</div>
      </div>
    </div>
  </div>

  <script src="https://cdn.scaledrone.com/scaledrone.min.js"></script>
  <script>
    const CHANNEL_ID = 'EoIG3R1I4JdyS4L1'; // Replace with your Scaledrone channel ID
    const ROOM_NAME = 'observable-voip-group-room';

    let drone = null, room = null, localStream = null;
    let members = [];
    const peerConnections = {};
    const videoElements = {};
    const iceCandidateQueues = {};

    const startCallBtn = document.getElementById('startCallBtn');
    const joinCallBtn = document.getElementById('joinCallBtn');
    const statusEl = document.getElementById('status');
    const membersEl = document.getElementById('members');
    const videosEl = document.getElementById('videos');
    const localVideo = document.getElementById('localVideo');

    function logStatus(msg) { statusEl.textContent = msg; }

    function showMembersWithStatus() {
      membersEl.innerHTML = "<strong>Room members:</strong> ";
      members.forEach((m, idx) => {
        const span = document.createElement('span');
        span.textContent = m.id === drone.clientId ? `${m.id} (You)` : m.id;
        span.style.color = m.id === drone.clientId ? '#81d4fa' : '#bbb';
        membersEl.appendChild(span);
        if (idx < members.length - 1) {
          membersEl.appendChild(document.createTextNode(', '));
        }
      });
    }

    drone = new ScaleDrone(CHANNEL_ID);
    drone.on('open', error => {
      if (error) { logStatus("Scaledrone connection failed."); return; }
      logStatus("Connected to Scaledrone.");
      room = drone.subscribe(ROOM_NAME);

      room.on('open', err => {
        if (err) { logStatus("Room join error."); }
      });

      room.on('members', ms => {
        members = ms;
        showMembersWithStatus();
      });

      room.on('member_join', member => {
        members.push(member);
        showMembersWithStatus();
      });

      room.on('member_leave', member => {
        members = members.filter(m => m.id !== member.id);
        if (peerConnections[member.id]) {
          peerConnections[member.id].close();
          delete peerConnections[member.id];
        }
        if (videoElements[member.id]) {
          videoElements[member.id].remove();
          delete videoElements[member.id];
        }
        showMembersWithStatus();
      });

      room.on('data', (data, client) => {
        if (!client || client.id === drone.clientId) return;
        handleSignalingData(data, client.id);
      });
    });

    function sendSignal(targetId, body) {
      drone.publish({
        room: ROOM_NAME,
        message: {
          to: targetId,
          from: drone.clientId,
          data: body
        }
      });
    }

    startCallBtn.onclick = async function () {
      if (!localStream) {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
          localVideo.srcObject = localStream;
          members.forEach(m => {
            if (m.id !== drone.clientId) createPeerConnection(m.id, true);
          });
          showMembersWithStatus();
          logStatus("Start Call: local media acquired and connections initiated.");
        } catch(e) {
          logStatus("Could not access camera/microphone.");
          return;
        }
      }
      members.forEach(m => {
        if (m.id !== drone.clientId) sendSignal(m.id, { type: 'JOIN_CALL' });
      });
      logStatus("Start Call: invited others to join.");
    };

    joinCallBtn.onclick = async function () {
      if (localStream) return;
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
        localVideo.srcObject = localStream;
        members.forEach(m => {
          if (m.id !== drone.clientId) createPeerConnection(m.id, true);
        });
        showMembersWithStatus();
        logStatus("Joined call. Connecting...");
      } catch (e) {
        logStatus("Could not access camera/microphone.");
      }
    };

    function createPeerConnection(peerId, isInitiator) {
      if (peerConnections[peerId]) return peerConnections[peerId];

      const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
      peerConnections[peerId] = pc;
      iceCandidateQueues[peerId] = [];
      showMembersWithStatus();

      if (localStream) {
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      }

      pc.onicecandidate = event => {
        if (event.candidate) sendSignal(peerId, { type: 'ICE', candidate: event.candidate });
      };

      pc.ontrack = event => {
        if (!videoElements[peerId]) {
          const video = document.createElement('video');
          video.setAttribute('playsinline', '');
          video.autoplay = true;
          video.controls = true;
          video.style.maxWidth = "280px";
          video.style.borderRadius = "12px";
          video.style.backgroundColor = "#000";

          const block = document.createElement('div');
          block.className = 'video-block';

          const label = document.createElement('div');
          label.className = 'video-label';
          label.textContent = peerId;

          block.appendChild(video);
          block.appendChild(label);
          videosEl.appendChild(block);
          videoElements[peerId] = block;
        }
        videoElements[peerId].querySelector('video').srcObject = event.streams[0];
      };

      if (isInitiator) {
        pc.createOffer()
          .then(offer => pc.setLocalDescription(offer))
          .then(() => sendSignal(peerId, { type: 'OFFER', sdp: pc.localDescription }));
      }

      return pc;
    }

    async function handleSignalingData(message, fromId) {
      const { type, sdp, candidate } = message.data || message;
      if (message.to && message.to !== drone.clientId) return;

      switch (type) {
        case 'JOIN_CALL':
          if (localStream) createPeerConnection(fromId, false);
          break;
        case 'OFFER': {
          const pc = peerConnections[fromId] || createPeerConnection(fromId, false);
          await pc.setRemoteDescription(new RTCSessionDescription(sdp));
          for (let c of iceCandidateQueues[fromId]) {
            await pc.addIceCandidate(c);
          }
          iceCandidateQueues[fromId] = [];
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          sendSignal(fromId, { type: 'ANSWER', sdp: pc.localDescription });
          break;
        }
        case 'ANSWER': {
          const pc = peerConnections[fromId];
          if (!pc) return;
          await pc.setRemoteDescription(new RTCSessionDescription(sdp));
          for (let c of iceCandidateQueues[fromId]) {
            await pc.addIceCandidate(c);
          }
          iceCandidateQueues[fromId] = [];
          break;
        }
        case 'ICE': {
          const pc = peerConnections[fromId];
          if (!pc) return;
          const iceCandidate = new RTCIceCandidate(candidate);
          if (pc.remoteDescription && pc.remoteDescription.type) {
            await pc.addIceCandidate(iceCandidate);
          } else {
            iceCandidateQueues[fromId].push(iceCandidate);
          }
          break;
        }
      }
      showMembersWithStatus();
    }
  </script>
</body>
</html>
